package sailpoint.services.api.idx;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import sailpoint.idx.SPObject;

/**
 * Utility class designed to analyze a given csv file generated by the following sql:
 * 
 * select id,[parent id],idx from spt_table order by idx
 * 
 * The goal is to parse the csv and create SBObject objects.  Any object
 * that is marked to have a parent will be rolled into a list of children for a that given parent.
 * If that SPObject doesn't yet exist (because the parent's id is found later in the query), it'll be boot-strapped.
 * If that SPObject comes up later, it will have its attributes updated.
 * 
 * Results: After iteration, examine each SPObject's child list and confirm the list elements have appropriate
 * 	idx values (no missing values, no overlapping values)
 * 
 * SPObject pojo:
 * 	-id
 * 	-children
 *  -parent
 *  -idx
 *  
 *  @see IDXSQLAnalyzerExecutor
 **/
public class AnalyzeSQL {

	private ResultSet _data;
	private Map<String, SPObject> _spObjs = new HashMap<String, SPObject>();
	private boolean _ordered;

	public AnalyzeSQL (ResultSet rs, boolean ordered) {
		_data = rs;
		_ordered = ordered;
	}

	private List<String> _columns = new ArrayList<String>();
	private String _parent = "PARENT";

	public void setParentColumn (String parent) {
		_parent = parent;
	}

	/**
	 * Analyze the list without depending on the list being ordered by parent, idx.  This requires
	 * information to be held on to as we iterate over the list resulting in more memory utilization
	 * @return A {@link Set} of IDs where issues were found
	 * @throws SQLException
	 */
	public Set<String> unOrderedAnalyze() throws SQLException {
		ResultSetMetaData metaData = _data.getMetaData();
		int cols = 1;

		// build columns
		if ( metaData != null ) {
			cols = metaData.getColumnCount();
			for ( int i = 1 ; i <= cols; i++ ) {
				_columns.add(metaData.getColumnName(i));
			}
		}

		int idIndex = _columns.indexOf("ID");
		int identityIndex = _columns.indexOf(_parent );
		int idxIndex = _columns.indexOf("IDX");
		while (_data.next()) {
			String[] values = new String[3];
			for ( int i = 1; i <= cols; i++ ) {
				String col = _data.getString(i);
				if (col == null) col = "";
				values[i - 1] = col;
			}
			if (values[idIndex] != null) {
				SPObject spObj = getSPObj (values[idIndex], "", values[identityIndex], values[idxIndex]);
				String parent = values[identityIndex];
				if (parent != null && !parent.equals("")) {
					SPObject parentObj = getSPObj (spObj.getParent());
					// add child to parent
					parentObj.addChild(spObj);
					_spObjs.put(spObj.getParent(), parentObj);
				}
				_spObjs.put(values[idIndex], spObj);
			}
		}

		// report() analyzes _spObjs and returns a Set<String> of problems found
		return report();				
	}

	/**
	 * We've ordered by parent.  Thus when the parent value changes, we have all we need to determine
	 * if there's a problem with the current set of objects.  So analyze and then let the GC clean up.  This
	 * will reduce the memory footprint.
	 * @return {@link Set} of IDs where issues were found
	 * @throws SQLException
	 */
	public Set<String> orderedAnalyze() throws SQLException {
		ResultSetMetaData metaData = _data.getMetaData();
		Set<String> fixes = new TreeSet<String>();
		int cols = 1;
		String lastParent = "";

		// build columns
		if ( metaData != null ) {
			cols = metaData.getColumnCount();
			for ( int i = 1 ; i <= cols; i++ ) {
				_columns.add(metaData.getColumnName(i));
			}
		}

		int idIndex = _columns.indexOf("ID");
		int identityIndex = _columns.indexOf(_parent );
		int idxIndex = _columns.indexOf("IDX");
		while (_data.next()) {
			String[] values = new String[3];
			for ( int i = 1; i <= cols; i++ ) {
				String col = _data.getString(i);
				if (col == null) col = "";
				values[i - 1] = col;
			}
			if (values[idIndex] != null) {
				SPObject spObj = getSPObj (values[idIndex], "", values[identityIndex], values[idxIndex]);
				String parent = values[identityIndex];
				// If we've changed parents, analyze the last bunch and then GC
				if (!lastParent.equals(parent)) {
					fixes.addAll(report());
					// reset _spObjs
					_spObjs = new HashMap<String, SPObject>();
				}
				if (parent != null && !parent.equals("")) {
					SPObject parentObj = getSPObj (spObj.getParent());
					// add child to parent
					parentObj.addChild(spObj);
					_spObjs.put(spObj.getParent(), parentObj);

				}
				_spObjs.put(values[idIndex], spObj);
			}
		}
		fixes.addAll(report());
		return fixes;			
	}

	/*
	 * Initiates the analyze methods based on wether the data is ordered by parent id or not
	 */
	public Set<String> analyze() throws SQLException {
		if (!_ordered) {
			// use the old method that doesn't trust the order of the sql
			return unOrderedAnalyze();
		} else {
			// use the new method that trusts the sql to be ordered by identity_id, then idx
			return orderedAnalyze();
		}    
	}

	/*
	 * Helpsies
	 */
	private SPObject[] getOrderedArray (Collection<SPObject> objs) {
		SPObject[] arrySPObjs = new SPObject[objs.size()];
		arrySPObjs = objs.toArray(arrySPObjs);
		Arrays.sort(arrySPObjs);
		return arrySPObjs;
	}

	private SPObject getSPObj (String id) {
		SPObject obj = _spObjs.get(id);
		if (obj == null) {
			return getSPObj (id, null, null, null);
		} else {
			return obj;
		}
	}

	private SPObject getSPObj (String id, String name, String parent, String idx) {
		SPObject obj = _spObjs.get(id);
		if (obj == null) {
			obj = new SPObject (id, name, parent, idx);
		} else {
			obj.setId(id);
			//			obj.setName(name);
			obj.setParent(parent);
			obj.setIdx(idx);
		}
		return obj;
	}

	private String increaseIncrement(String currentIncrement) {
		String nextIncrement = "   ";
		return currentIncrement + nextIncrement;
	}

	private Set<String> report() {

		SPObject[] spObjs = getOrderedArray (_spObjs.values());
		Set<String> fixes = new TreeSet<String>();
		for (SPObject spObj : spObjs) {
			fixes.addAll(report (spObj, ""));
		}
		return fixes;
	}


	/*
	 * The method that does the actual analysis.  Returns a list of issues
	 */
	private Set<String> report(SPObject spObj, String increment) {
		//System.out.println (increment + cert.toString());
		SPObject[] children = getOrderedArray(spObj.getChildren());
		Set<String> fixes = new TreeSet<String>();
		int size = children.length;
		int lastIdx = -1;
		if (
				(spObj.getIdx() == null || spObj.getIdx().equals(""))
				&&
				(spObj.getParent() != null && !spObj.getParent().equals(""))
		)
		{
			// I wonder why i put this in a code block.  I'm sure it's VERY important.
			//warn (spObj.getIdx(), spObj.getParent(), "Null idx with parent! " + spObj.toString());

			fixes.add(spObj.getParent());
		}
		for (SPObject child : children) {
			try {
				int thisIdx = Integer.valueOf(child.getIdx());
				if (thisIdx != lastIdx + 1) {
					//warn (child.getId(), spObj.getId(), "IDX aren't sequential!");

					fixes.add(spObj.getId());

				}
				lastIdx = thisIdx;
			} catch (Exception e) {
				//warn (child.getId(), spObj.getId(), "IDX issue for: " + child.toString());

				fixes.add(spObj.getId());

			}

			fixes.addAll(report (child, increaseIncrement(increment)));
		}
		if (lastIdx != size - 1) {
			//warn ("", spObj.getId(), "IDX list size != Reported elements");
			fixes.add(spObj.getId());
		}

		return fixes;
	}

}
/**
 * Utility class to store the attributes in a specialize Map of sorts.
 * @author trey.kirk
 *
 */
class SPObject implements Comparable<SPObject> {
	private List<SPObject> children;
	private String id;
	private String idx;
	private String name;
	private String parent;

	SPObject(String id, String name, String parent, String idx) {
		this.id = id;
		this.parent = parent;
		this.idx = idx;
		this.name = name;
		children = new ArrayList<SPObject>();
	}

	void addChild (SPObject child) {
		children.add(child);
	}

	public int compareTo(SPObject yours) {
		String yourIdx = yours.getIdx();
		// are you null?
		if (yourIdx == null || yourIdx.equals("")) {
			if (getIdx() == null || getIdx().equals("")) {
				// we are equally null
				return 0;
			} else {
				// I am not null, I am greater
				return 1;
			}
		} else {
			// you are not null, am I?
			if (getIdx() == null || getIdx().equals("")) {
				// I am null, I am less
				return -1;
			} else if (getIdx().equals(yourIdx)) {
				// We are equal
				return 0;
			} else {
				// We are not null nor are we equal, compare integer values
				int yourIntIdx = Integer.valueOf(yourIdx);
				int myIntIdx = Integer.valueOf(getIdx());
				if (yourIntIdx > myIntIdx) {
					// Your integer value is greater, I am less
					return -1;
				} else {
					// I am greater
					return 1;
				}
			}
		}
	}

	/**
	 * @return the children
	 */
	List<SPObject> getChildren() {
		return children;
	}

	/**
	 * @return the id
	 */
	String getId() {
		return id;
	}

	/**
	 * @return the idx
	 */
	String getIdx() {
		return idx;
	}

	String getName() {
		return this.name;
	}

	/**
	 * @return the parent
	 */
	String getParent() {
		return parent;
	}

	/**
	 * @param id the id to set
	 */
	void setId(String id) {
		this.id = id;
	}

	/**
	 * @param idx the idx to set
	 */
	void setIdx(String idx) {
		this.idx = idx;
	}

	void setName (String name) {
		this.name = name;
	}

	/**
	 * @param parent the parent to set
	 */
	void setParent(String parent) {
		this.parent = parent;
	}

	public String toString() {
		StringBuffer out = new StringBuffer();
		out.append("ID: " + id + "::");
		out.append("NAME: " + name + "::");
		out.append("PARENT: " + parent + "::");
		out.append("IDX: " + idx);
		return out.toString();
	}
}
